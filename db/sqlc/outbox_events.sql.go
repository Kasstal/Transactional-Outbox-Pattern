// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: outbox_events.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOutboxEvent = `-- name: CreateOutboxEvent :one
INSERT INTO outbox_events (
    id, aggregate_type, aggregate_id, event_type,
    payload, status, retry_count
) VALUES (
             $1, $2, $3, $4, $5, $6, $7
         ) RETURNING id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at
`

type CreateOutboxEventParams struct {
	ID            pgtype.UUID     `json:"id"`
	AggregateType string          `json:"aggregate_type"`
	AggregateID   pgtype.UUID     `json:"aggregate_id"`
	EventType     string          `json:"event_type"`
	Payload       json.RawMessage `json:"payload"`
	Status        string          `json:"status"`
	RetryCount    pgtype.Int4     `json:"retry_count"`
}

func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.ID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
		arg.Status,
		arg.RetryCount,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const deleteOutboxEvent = `-- name: DeleteOutboxEvent :exec
DELETE FROM outbox_events WHERE id = $1
`

func (q *Queries) DeleteOutboxEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOutboxEvent, id)
	return err
}

const getOutboxEvent = `-- name: GetOutboxEvent :one
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at FROM outbox_events WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutboxEvent(ctx context.Context, id pgtype.UUID) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, getOutboxEvent, id)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getPendingOutboxEvents = `-- name: GetPendingOutboxEvents :many
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at FROM outbox_events WHERE status = 'pending' LIMIT $1
`

func (q *Queries) GetPendingOutboxEvents(ctx context.Context, limit int32) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, getPendingOutboxEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboxEvent
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.CreatedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutboxEventStatus = `-- name: UpdateOutboxEventStatus :one
UPDATE outbox_events
SET
    status = $2,
    retry_count = $3,
    processed_at = CASE WHEN $2 = 'processed' THEN now() ELSE processed_at END,
    payload = $4
WHERE id = $1
    RETURNING id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at
`

type UpdateOutboxEventStatusParams struct {
	ID         pgtype.UUID     `json:"id"`
	Status     string          `json:"status"`
	RetryCount pgtype.Int4     `json:"retry_count"`
	Payload    json.RawMessage `json:"payload"`
}

func (q *Queries) UpdateOutboxEventStatus(ctx context.Context, arg UpdateOutboxEventStatusParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, updateOutboxEventStatus,
		arg.ID,
		arg.Status,
		arg.RetryCount,
		arg.Payload,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
	)
	return i, err
}
