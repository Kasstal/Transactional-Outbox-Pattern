// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: outbox_events.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchPendingTasks = `-- name: BatchPendingTasks :many
WITH batch AS (
    SELECT id
    FROM outbox_events
    WHERE status = 'pending'
    LIMIT $1
    )
UPDATE outbox_events
SET status = 'in_progress'
WHERE id IN (SELECT id FROM batch)
RETURNING id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message
`

func (q *Queries) BatchPendingTasks(ctx context.Context, limit int32) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, batchPendingTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboxEvent
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createOutboxEvent = `-- name: CreateOutboxEvent :one
INSERT INTO outbox_events (
    aggregate_type, aggregate_id, event_type,
    payload, status, retry_count
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message
`

type CreateOutboxEventParams struct {
	AggregateType string          `json:"aggregate_type"`
	AggregateID   pgtype.UUID     `json:"aggregate_id"`
	EventType     string          `json:"event_type"`
	Payload       json.RawMessage `json:"payload"`
	Status        string          `json:"status"`
	RetryCount    pgtype.Int4     `json:"retry_count"`
}

func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
		arg.Status,
		arg.RetryCount,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const deleteOutboxEvent = `-- name: DeleteOutboxEvent :exec
DELETE FROM outbox_events WHERE id = $1
`

func (q *Queries) DeleteOutboxEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOutboxEvent, id)
	return err
}

const fetchOnePendingForUpdate = `-- name: FetchOnePendingForUpdate :one
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message
FROM outbox_events
WHERE status = 'pending' FOR UPDATE NOWAIT LIMIT 1
`

func (q *Queries) FetchOnePendingForUpdate(ctx context.Context) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, fetchOnePendingForUpdate)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const fetchOnePendingForUpdateWithID = `-- name: FetchOnePendingForUpdateWithID :one
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message
FROM outbox_events
WHERE id = $1 FOR UPDATE NOWAIT LIMIT 1
`

func (q *Queries) FetchOnePendingForUpdateWithID(ctx context.Context, id pgtype.UUID) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, fetchOnePendingForUpdateWithID, id)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getAllInProgressOutboxEvents = `-- name: GetAllInProgressOutboxEvents :many
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message FROM outbox_events WHERE status = 'in_progress'
`

func (q *Queries) GetAllInProgressOutboxEvents(ctx context.Context) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, getAllInProgressOutboxEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboxEvent
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutboxEvent = `-- name: GetOutboxEvent :one
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message FROM outbox_events WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOutboxEvent(ctx context.Context, id pgtype.UUID) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, getOutboxEvent, id)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getPendingOutboxEvents = `-- name: GetPendingOutboxEvents :many
SELECT id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message FROM outbox_events WHERE status = 'pending'
                            FOR UPDATE SKIP LOCKED
                             LIMIT $1
`

func (q *Queries) GetPendingOutboxEvents(ctx context.Context, limit int32) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, getPendingOutboxEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboxEvent
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementRetryCount = `-- name: IncrementRetryCount :one
UPDATE outbox_events
SET retry_count = retry_count + 1,
    status = 'pending',
    error_message = $2
WHERE id = $1 RETURNING retry_count
`

type IncrementRetryCountParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) IncrementRetryCount(ctx context.Context, arg IncrementRetryCountParams) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, incrementRetryCount, arg.ID, arg.ErrorMessage)
	var retry_count pgtype.Int4
	err := row.Scan(&retry_count)
	return retry_count, err
}

const markEventError = `-- name: MarkEventError :exec
UPDATE outbox_events
SET
    status = 'failed',
    error_message = $2,
    processed_at = NOW()
WHERE id = $1
`

type MarkEventErrorParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) MarkEventError(ctx context.Context, arg MarkEventErrorParams) error {
	_, err := q.db.Exec(ctx, markEventError, arg.ID, arg.ErrorMessage)
	return err
}

const updateOutboxEventStatus = `-- name: UpdateOutboxEventStatus :one
UPDATE outbox_events
SET
    status = $1::varchar(20),
    processed_at = CASE WHEN $1 = 'processed' THEN now() ELSE processed_at END
WHERE id = $2
    RETURNING id, aggregate_type, aggregate_id, event_type, payload, status, retry_count, created_at, processed_at, error_message
`

type UpdateOutboxEventStatusParams struct {
	Status string      `json:"status"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateOutboxEventStatus(ctx context.Context, arg UpdateOutboxEventStatusParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, updateOutboxEventStatus, arg.Status, arg.ID)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ErrorMessage,
	)
	return i, err
}
